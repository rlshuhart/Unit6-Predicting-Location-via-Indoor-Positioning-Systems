---
title: "Predicting Location via Indoor Positioning Systems"
author: "Brett Hallum, Chris Ficklin, and Ryan Shuhart"
date: "February 2017"
output:
  html_notebook: default
  html_document: default
  pdf_document: default
subtitle: MSDS 7333-401
---

## Introduction

The low cost and near ubiquity of wireless networking infrastructure in buildings has brought with it a long desired side benefit, the ability to track people and equipment moving through a space in near real-time. The goal of knowing who and what are in a location and the ability to track their movements has many applications for which solutions have long been sought. In grocery stores, for instance, significant resources were commonly used to study the paths shoppers took from the time they arrived until they left. Data could be used to plan the layout of goods, to sell shelf space at a premium, and to assist in dedicating loss prevention resources. These efforts were costly and nowhere near real-time, and did not easily account for future layout changes.

Now with Wi-Fi equipment such as access points in place or easily deployed, it is possible to track the location of devices that continuously communicate with the fixed wireless infrastructure. Equipment such as laptops can be tracked for security purposes within an office, for instance, to ensure that they stay on site or to record when and where they departed. Such information can flag alerts or be cross-referenced with other access controls such as key cards and video surveillance to ensure the security of physical and intellectual property.

People who carry phones or other equipment meant to communicate with the Wi-Fi access points can be similarly tracked. Of important note is the fact that a device need not fully connect to a wireless network. It is sufficient that the radio merely be turned on since it regularly identifies itself to seek out potential access points with which it may connect. 
In this case study we use the R language to process raw data collected from an existing wireless infrastructure and develop an analytical engine to create an indoor positioning system (IPS) to achieve this location awareness.

## Description of Data
blah blah

## Brief Exploration of the Data
I like to paint by color..


```{r, include=FALSE}
# Libraries
library(dplyr) # Data transformations
library(tidyr) # Data transformations
library(ggplot2) # Visualizations
library(data.table)
library(scales)
library(gridExtra)
library(stats)
library(knitr) # Markdown tables
library(DataExplorer) # Simplyfied common ggplots
library(FNN) #KNN Regression
```


```{r, echo=FALSE}
# Import Pre-processed Data
offline <- readRDS("../data/processed/offline.rds")
online_allmacs <- readRDS("../data/processed/online_allmacs.rds")

```
### Data Description



```{r, echo=FALSE}
#### Create Data Set by Time
offlineByTime <- group_by(offline, time, posXY, mac,  angle) %>%
  summarize(avgSig = mean(signal)) %>%
  spread(mac, avgSig) %>%
  ungroup()%>%
  rename(sig_cd = `00:0f:a3:39:dd:cd`,
         sig_c0 = `00:0f:a3:39:e1:c0`, 
         sig_c6 = `00:14:bf:3b:c7:c6`,
         sig_81 = `00:14:bf:b1:97:81`,
         sig_8a = `00:14:bf:b1:97:8a`,
         sig_8d = `00:14:bf:b1:97:8d`,
         sig_90 = `00:14:bf:b1:97:90`)

#During the pdf process, knitr will lable the table number. Looks worse in html
kable(offlineByTime[1:5,], caption = "Offline Data - First Observations")
```
```{r, echo=FALSE}
dim(offlineByTime)
```
The offlineByTime data frame is generated by pivoting the mac addresses and signal strength from rows to columns. This pivot makes the shape of the data wider, but reduces the rows from 914,951 to 146,074. The columns 'orientation', 'rawTime', 'posX', and 'posY' are excluded for this view of the data. 

### Exploratoration of Offline Data

```{r, echo=FALSE}
AP <- data.frame(Label=c("sig_c0", "sig_8a", "sig_c6", "sig_90", "sig_8d", "sig_81"),
                 posX=c(7.5,2.5,12.8,1,33.5,33.5), 
                 posY=c(6.3,-.8,-2.8,14.0,9.3,2.8), 
                 Type="Access Point")

offlinePoints <- unique(offline[,c("posX","posY")])
offlinePoints$Type <- "Offine - Training"

onlinePoints <- unique(online_allmacs[,c("posX","posY")])
onlinePoints$Type <- "Online - Test"

building <- rbind(offlinePoints, select(AP, -Label), onlinePoints)

ggplot(building, aes(x=posX, y=posY)) + 
  geom_point(aes(shape=Type, color=Type)) + 
  geom_text(data=filter(AP, !(Label %in% c("sig_90", "sig_8d"))), aes(label=Label), nudge_y = -.6) +
  geom_text(data=filter(AP, Label == "sig_90"), aes(label=Label), nudge_x = 2) +
  geom_text(data=filter(AP, Label == "sig_8d"), aes(label=Label), nudge_x = -2) +
  labs(title="(Fig. 1) Floor Plan") + 
  scale_shape_manual(values = c(8,16,16)) +
  scale_colour_manual(values=c("red","black","#0DC3FF")) +
  theme_bw() +
  theme(axis.title.x=element_blank(), 
        axis.title.y=element_blank(), 
        axis.text.x=element_blank(), 
        axis.text.y=element_blank(),
        panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),
        axis.ticks=element_blank())
```
Figure 1 plots the current floor plan of the warehouse and the locations of the training points, seen in black, and the test points, seen in blue. The training points, or Offline data, are 1 meter apart.

### Offline Missing Data
```{r, echo=FALSE}
# Modified from DataExplorer library by boxuancui 
# https://github.com/boxuancui/DataExplorer
plotMissing <- function(data, title=NULL) {
  ## Declare variable first to pass R CMD check
  feature <- num_missing <- pct_missing <- group <- NULL
  ## Check if input is data.table
  is_data_table <- TRUE
  ## Detect input data class
  data_class <- class(data)
  ## Set data to data.table
  if (!is_data_table) {data <- data.table(data)}
  ## Extract missing value distribution
  missing_value <- data.table("feature" = names(data), "num_missing" = sapply(data, function(x) {sum(is.na(x))}))
  missing_value[, feature := factor(feature, levels = feature[order(-rank(num_missing))])]
  missing_value[, pct_missing := num_missing / nrow(data)]
  missing_value[pct_missing < 0.05, group := "Good"]
  missing_value[pct_missing >= 0.05 & pct_missing < 0.4, group := "OK"]
  missing_value[pct_missing >= 0.4 & pct_missing < 0.8, group := "Bad"]
  missing_value[pct_missing >= 0.8, group := "Remove"][]
  ## Set data class back to original
  if (!is_data_table) {class(missing_value) <- data_class}
  ## Create ggplot object
  output <- ggplot(missing_value, aes_string(x = "feature", y = "num_missing", fill = "group")) +
    geom_bar(stat = "identity", colour = "black", alpha = 0.4) +
    geom_text(aes(label = paste0(round(100 * pct_missing, 0), "%")), hjust = -0.15, size = 3.5) +
    scale_fill_manual("Group", values = c("Good" = "#1a9641", "OK" = "#a6d96a", "Bad" = "#fdae61", "Remove" = "#d7191c"), breaks = c("Good", "OK", "Bad", "Remove")) +
    scale_y_continuous(labels = comma) +
    theme(legend.position = c("bottom")) + coord_flip() +
    xlab("Features") + ylab("Number of missing rows") + ggtitle(title)
  ## Print plot
  print(output)
  ## Set return object
  return(invisible(missing_value))
}

plotMissing(offlineByTime, "(Fig. 2) - Offline Missing Data")
```


Many of the routers do not receive data about each of the data points from the device. From the missing data, we see that each receiver misses about 18% of the signals produced by emitting device. This contrasts with 2 of the routers, 00:0f:a3:39:dd:cd and 00:0f:a3:39:e1:c0, which miss around 1% of the signals emitted.

```{r, echo=FALSE}
paste("There are ", format(sum(complete.cases(offlineByTime)),big.mark=",",scientific=FALSE),
      " (", sprintf("%.1f", sum(complete.cases(offlineByTime))/nrow(offlineByTime)*100), "%)", 
      " complete rows of data.", sep="")
```



#### (Fig. 3) Histogram of Signal Strengths
```{r, echo=FALSE}
# This type of plot does not allow a title of the grid
HistogramContinuous(offlineByTime %>% select(-posXY, -time, -angle))
```
The above histograms show the frequency of signal strengths recorded for each of the routers producing signals. The further to the right on each of the graphs, the stronger the signal is. The signal strength at any given point is related to the distance away from the source.

#### Create Train Data Set by Using Average Signal
```{r, echo=FALSE}
offlineByAvgSig <- group_by(offline, posXY, posX, posY, mac,  angle) %>%
  summarize(avgSig = mean(signal)) %>%
  spread(mac, avgSig) %>%
  ungroup()%>%
  rename(sig_cd = `00:0f:a3:39:dd:cd`,
         sig_c0 = `00:0f:a3:39:e1:c0`, 
         sig_c6 = `00:14:bf:3b:c7:c6`,
         sig_81 = `00:14:bf:b1:97:81`,
         sig_8a = `00:14:bf:b1:97:8a`,
         sig_8d = `00:14:bf:b1:97:8d`,
         sig_90 = `00:14:bf:b1:97:90`)

kable(select(offlineByAvgSig[1:5,], -posXY), caption="Offline Data - First Observations of Signal Averages by Postion and Angle")
```
To account for the multiple entries of data for a given time, angle, position, and MAC address, the signal strengths are averaged to provide a single row of signal values for a given reading. This provides us with an appropriate training data set without repeats of data points.

### Online Data
Online Data has duplicate observations given the time, position, mac, and angle. Similar to the training data set above, the signal strengths will need to be averaged for situations where these tuplets of data occur, resulting in a single series of signal data for a given position, mac address and angle.
```{r, echo=FALSE}
percDuplicated <- nrow(online_allmacs[duplicated(online_allmacs[,c("time", "posXY", "mac", "angle")]),])/nrow(online_allmacs)

paste(sprintf("%.1f", percDuplicated*100), "% of the online observations are duplicated.", sep="")
```

The online data used for knn is grouped by access point, position, and angle and will average each of the signal observations. This averaging is done, as noted above, to account for multiple positions, angle and MAC addresses having multple signal readings.
```{r, echo=FALSE}
onlineByAvgSig <- group_by(online_allmacs, posXY, posX, posY, mac,  angle) %>%
  summarize(avgSig = mean(signal)) %>%
  spread(mac, avgSig)%>%
  ungroup()%>%
  rename(sig_cd = `00:0f:a3:39:dd:cd`,
         sig_c0 = `00:0f:a3:39:e1:c0`, 
         sig_c6 = `00:14:bf:3b:c7:c6`,
         sig_81 = `00:14:bf:b1:97:81`,
         sig_8a = `00:14:bf:b1:97:8a`,
         sig_8d = `00:14:bf:b1:97:8d`,
         sig_90 = `00:14:bf:b1:97:90`) 

kable(select(onlineByAvgSig[1:5,], -posXY), caption="Online Data - First Observations of Signal Averages by Postion and Angle")
```


### Using KNN Regression for K = 1, 3, & 5 using all angles
```{r, echo=FALSE}
offlinePosX <- offlineByAvgSig$posX
offlinePosY <- offlineByAvgSig$posY
offline_signals <- select(offlineByAvgSig, -posXY, -posX, -posY, -angle)
online_signals <- select(onlineByAvgSig, -posXY, -posX, -posY, -angle)

#k = 1
test_estXk1 <- knn.reg(offline_signals, online_signals, offlinePosX, k=1)$pred
test_estYk1 <- knn.reg(offline_signals, online_signals, offlinePosY, k=1)$pred
test_estXYk1 <- data.frame(posX = test_estXk1, posY = test_estYk1)

#k = 3
test_estXk3 <- knn.reg(offline_signals, online_signals, offlinePosX, k=3)$pred
test_estYk3 <- knn.reg(offline_signals, online_signals, offlinePosY, k=3)$pred
test_estXYk3 <- data.frame(posX = test_estXk3, posY = test_estYk3)

#k = 5
test_estXk5 <- knn.reg(offline_signals, online_signals, offlinePosX, k=5)$pred
test_estYk5 <- knn.reg(offline_signals, online_signals, offlinePosY, k=5)$pred
test_estXYk5 <- data.frame(posX = test_estXk5, posY = test_estYk5)

#MSE
#sum( rowSums( (estXY - actualXY)^2) )
sum( rowSums( (test_estXYk1 - onlineByAvgSig[,c("posX", "posY")])^2) )
sum( rowSums( (test_estXYk3 - onlineByAvgSig[,c("posX", "posY")])^2) )
sum( rowSums( (test_estXYk5 - onlineByAvgSig[,c("posX", "posY")])^2) )
```
The above results from our K Nearest Neighbors approximation of location show, without accounting for the angle of the signal and limiting the possible location based on angle that the signal was received at, we get the best KNN result when using K=5. This leads to an mean square error of 252.47, which is significantly better than the K=1 MSE of 529.04 and marginally better than the MSE for K=3 of 267.63.

We want to improve these results by limiting the angle observed and using the best possible K within the KNN prediction. The following graphs assit us in achieving both of these goals.

```{r, include=FALSE}
# function to estimate using KNN the X Y of the online data
predictXYKNN <- function(offline_signals, online_signals, 
                         offline_posX, offline_posY, k){
  
  estX <- knn.reg(offline_signals, online_signals, offline_posX$posX, k=k)$pred
  estY <- knn.reg(offline_signals, online_signals, offline_posY$posY, k=k)$pred
  
  estXYk <- data.frame(posXest = estX, posYest = estY)
  
  return(estXYk)
}

pred_XY_Nbr_Ang <- function(offlineByAvgSig, onlineByAvgSig, k){
  results <- data.frame(posXest=numeric(), posYest=numeric(), posX=numeric(),  posY=numeric())
  
  possibleAngles <- c(0,  45,  90, 135, 180, 225, 270, 315)
  
  # Goes through all possible online angles and runs KNN only on a filtered
  # offline group containing only the neighboring angles. Each group is a set
  # of online observations sharing the same angle. This group then uses KNN
  # on the offline group with the same angle and the angles directly to the 
  # left and right. After all the possible online angles are predicted, the
  # results are scored.
  for (ang in possibleAngles){ 
    angleLeft <- (ang - 45 + 360)%%360
    angleRight <-(ang + 45 + 360)%%360
    
    offline_signals <- select( 
      filter(offlineByAvgSig, angle %in% c(angleLeft, ang, angleRight)), 
      -posXY, -posX, -posY, -angle)
    
    offline_posX <- select(
      filter(offlineByAvgSig, angle %in% c(angleLeft, ang, angleRight)), 
      posX)
    
    offline_posY <- select(
      filter(offlineByAvgSig, angle %in% c(angleLeft, ang, angleRight)), 
      posY)
    
    online_signals <- select(
      filter(onlineByAvgSig, angle == ang),
      -posXY, -posX, -posY, -angle)
    
    online_positions_val <- select(
      filter(onlineByAvgSig, angle == ang),
      posX, posY)
    
    estXY <- predictXYKNN(offline_signals, online_signals, 
                          offline_posX, offline_posY, k)
    
    # The results of each group have to be combined before scoring
    results <- rbind(results, cbind(estXY, online_positions_val))
  }
  return(results)
}

# function to evaluate a series of k values and only looking at angle directly
# to the left or the right
k_Eval <- function(offlineByAvgSig, onlineByAvgSig, k_max){
  ks=numeric()
  MSE=numeric()
  
  for (k in 1:k_max){
    ks[k] <- k
    results <- pred_XY_Nbr_Ang(offlineByAvgSig, onlineByAvgSig, k)
    #MSE of all the completed online predictions
    MSE[k] <- sum( rowSums( (results[,c("posXest","posYest")] - results[,c("posX","posY")])^2) )
  }
  return(data.frame(k=ks, MSE=MSE))
}
```

```{r, echo=FALSE}
mse_allsigs <-  k_Eval(offlineByAvgSig, onlineByAvgSig, 20)
mse_allsigs$Method <- "All Signals"

mse_6sigscc <- k_Eval(select(offlineByAvgSig, -sig_c0), select(onlineByAvgSig, -sig_c0), 20)
mse_6sigscc$Method <- "6 Signals - dd:cc"

mse_6sigsco <-  k_Eval(select(offlineByAvgSig, -sig_cd), select(onlineByAvgSig, -sig_cd), 20) 
mse_6sigsco$Method <- "6 Signals - e1:c0"

mse_all_no_wt <- rbind(mse_allsigs, mse_6sigscc, mse_6sigsco)

ggplot(mse_all_no_wt, aes(k, MSE)) + 
  geom_line(aes(color=Method), size=1.4) + 
  theme_classic() + 
  scale_colour_manual(values=c("#0C38E8","#0CE85A", "#00E6FF")) +
  labs(title="(Fig. 4) - Three Signal Methods - Unweighted") 

```

```{r, echo=FALSE}
# Table - Best Results by Method
kable(mse_all_no_wt %>% 
        group_by(Method) %>% 
        top_n(-1,MSE) %>% # the -1 makes it the bottom first rather than top first. 
        arrange(MSE) %>% 
        select(Method, k, MSE), 
      caption="Best Results - Unweighted")
```

```{r, echo=FALSE}
# Create weighted data

wt_signals <- function(ByAvgSig){
  signals <- select(ByAvgSig, -posXY, -posX, -posY, -angle) 
  loc_ang <- select(ByAvgSig, posXY, posX, posY, angle)
  
  weighted_signals <- (1/signals) / rowSums(1/signals)
  
  return(cbind(loc_ang, weighted_signals))
}

wtOfflineByAvgSig <- wt_signals(offlineByAvgSig)
wtOnlineByAvgSig <- wt_signals(onlineByAvgSig)
```

From Figure 4 above, we are able to determine the best value of K to use when predicting the location of the signal reading device. We find the best K to use for utilizing all 7 routers is 4, which leads to an MSE of 201.34. When the router 00:0f:a3:39:e1:c0 is removed from the list, we use a K of 8 to obtain the best MSE of 207.23. Finally, removing the router 00:0f:a3:39:dd:cd, as is done by the original research team, results in a K of 5 with an MSE of 264.20.

From these results, we determine that the best method of determining location is to leave both of the routers included in the data set as it produces the smallest error, and thus, better accuracy. However, we know that there are only supposed to be 6 routers in the warehouse and these 2 that we are testing for elimination, 00:0f:a3:39:dd:cd and 00:0f:a3:39:e1:c0, are tagged at being in the same spot. Knowing this information, it is ideal to remove 00:0f:a3:39:e1:c0 instead of 00:0f:a3:39:dd:cd to achieve a smaller error when predicting the location of the device.

### Weighted

In an attempt to improve the accuracy of predicting location, we up-weight stronger signals relative to weaker signals. This will allow us to give strong, closer signals a larger impact on determining the location than those that are weak and further away. We use the weighting fraction below to achieve this result, where we use the signal strenght as an estimator for distance.

$$\frac{1/d}{\sum_{i=1}^k 1/d_i}$$

From the results in Figure 5 below, it seems that by weighting the signal strength, our estimate of distance, we do not improve the accuracy of the nearest neighbor calculation. Without weighting the best MSE was 201.34 while we see an MSE of 335.45 with the weighting. Removing 00:0f:a3:39:e1:c0 instead of 00:0f:a3:39:dd:cd still provides the best accuracy result. For the case of weighting, it is not advised to leave both signals in, as the use of 6 signals with 00:0f:a3:39:dd:cd included produces the best MSE of 335.45 compared to the MSE of all 7 routers included of 335.70.
```{r, echo=FALSE}

mse_allsigswt <-  k_Eval(wtOfflineByAvgSig, wtOnlineByAvgSig, 20)
mse_allsigswt$Method <- "All Weighted Signals"

mse_6sigsccwt <- k_Eval(select(wtOfflineByAvgSig, -sig_c0), select(wtOnlineByAvgSig, -sig_c0), 20)
mse_6sigsccwt$Method <- "6 Weighted Signals - dd:cc"

mse_6sigscowt <-  k_Eval(select(wtOfflineByAvgSig, -sig_cd), select(wtOnlineByAvgSig, -sig_cd), 20) 
mse_6sigscowt$Method <- "6 Weighted Signals - e1:c0"

mse_all_wt <- rbind(mse_allsigswt, mse_6sigsccwt, mse_6sigscowt)

ggplot(mse_all_wt, aes(k, MSE)) + 
  geom_line(aes(color=Method), size=1.4) + 
  theme_classic() + 
  scale_colour_manual(values=c("#E8AD0C", "#E8110C", "#FF6800")) +
  labs(title="(Fig. 5) - Three Signal Methods - Weighted") 

```
Table - Best Results by Method
```{r, echo=FALSE}
# Table - Best Results by Method
kable(mse_all_wt %>% 
        group_by(Method) %>% 
        top_n(-1,MSE) %>% 
        arrange(MSE) %>% 
        select(Method, k, MSE),
      caption = "Best Results - Weighted")
```


```{r, echo=FALSE}
mse_all <- rbind(mse_allsigs, mse_6sigscc, mse_6sigsco, 
                 mse_allsigswt, mse_6sigsccwt, mse_6sigscowt)

ggplot(mse_all, aes(k, MSE)) + 
  geom_line(aes(color=Method), size=1.4) + 
  theme_classic() + 
  scale_colour_manual(values=c("#0C38E8","#0CE85A", "#E8AD0C", 
                               "#E8110C", "#00E6FF","#FF6800")) +
  labs(title="(Fig. 6) - Three Signal Methods - Unweighted and Weighted") 

```
Table - Best Results by Method
```{r, echo=FALSE}
# Table - Best Results by Method
kable(mse_all %>% 
        group_by(Method) %>% 
        top_n(-1,MSE) %>% 
        arrange(MSE) %>% 
        select(Method, k, MSE),
      caption = "Best Results - All")
```



```{r, echo=FALSE}

best_all_sig <- pred_XY_Nbr_Ang(offlineByAvgSig, onlineByAvgSig, 4)
best_cc <-  pred_XY_Nbr_Ang(select(offlineByAvgSig, -sig_c0), select(onlineByAvgSig, -sig_c0), 8)
best_c0 <-  pred_XY_Nbr_Ang(select(offlineByAvgSig, -sig_cd), select(onlineByAvgSig, -sig_cd), 6) 


best_all_sig_dists <- best_all_sig %>% 
  transmute(Dist = sqrt((posX - posXest)^2 + (posY - posYest)^2)) %>% 
  arrange(desc(Dist))
best_all_sig_dists$Method <- "Best All Signals - k=4"
best_all_sig_dists$Index <- seq.int(nrow(best_all_sig_dists))

best_cc_dists <- best_cc %>% 
  transmute(Dist = sqrt((posX - posXest)^2 + (posY - posYest)^2)) %>% 
  arrange(desc(Dist))
best_cc_dists$Method <- "Best 6 Signals dd:cc - k=8"
best_cc_dists$Index <- seq.int(nrow(best_cc_dists))

best_c0_dists <- best_c0 %>% 
  transmute(Dist = sqrt((posX - posXest)^2 + (posY - posYest)^2)) %>% 
  arrange(desc(Dist))
best_c0_dists$Method <- "Best 6 Signals e1:c0 - k=6"
best_c0_dists$Index <- seq.int(nrow(best_c0_dists))

best_no_wt <- rbind(best_all_sig_dists, 
                    best_cc_dists,
                    best_c0_dists)

ggplot(best_no_wt, aes(y = Dist, x=Index, color=Method)) + 
  geom_area(stat="identity", size=.1, position = position_dodge(width = 0.0), alpha=.15, aes(fill=Method))+ 
  scale_colour_manual(values=c("#0C38E8","#0CE85A", "#00E6FF")) +
  scale_fill_manual(values=c("#0C38E8","#0CE85A", "#00E6FF")) +
  labs(title="(Fig. 7) Area Plot of Sorted Errors ") +
  theme_classic() 
```
The above shows the sorted distant errors from the true location to the predicted location of the 3 methods without weighting using the best k as previously discussed. The higher the line the larger the error for the series of points. The plot gives evidence signal dd:cc is superior to e1:c0 as the "Best 6 Signals dd:cc" is consistently below "Best 6 Signals e1:c0."  Compared to the "Best 6 Signals dd:cc", using all signals outperforms for a certain group towards the left side of the table, between Index 3 to 18, however, "Best 6 Signals dd:cc" outperforms between Index 20 to 35, but not as much to have a better MSE.


```{r, echo=FALSE}
p <- ggplot(building, aes(x=posX, y=posY)) + 
        geom_point(aes(shape=Type, color=Type)) + 
        geom_text(data=filter(AP, !(Label %in% c("sig_90", "sig_8d"))), aes(label=Label), nudge_y = -.6) +
        geom_text(data=filter(AP, Label == "sig_90"), aes(label=Label), nudge_x = 2) +
        geom_text(data=filter(AP, Label == "sig_8d"), aes(label=Label), nudge_x = -2) +
        labs(title="(Fig. 8) Floor Plan - Error Bars for Best KNN Using All Signals - No Weighting") + 
        scale_shape_manual(values = c(8,16,16)) +
        scale_colour_manual(values=c("red","black","#0DC3FF")) +
        theme_bw() +
        theme(axis.title.x=element_blank(), 
              axis.title.y=element_blank(), 
              axis.text.x=element_blank(), 
              axis.text.y=element_blank(),
              panel.grid.major=element_blank(),
              panel.grid.minor=element_blank(),
              axis.ticks=element_blank()) + 
  geom_segment(data=best_all_sig, aes(x = posX, y=posY, xend = posXest, yend = posYest), color="red", size=1)

p 

```
### Improvements and Future Work

  The models we used to look at the signals consisted of the signals for all of the possible angles and  the angle we were observing and the angles 45 degrees away on either side. It is possible that there are other angle combinations besides this one that would produce better results. We observed all the angles included which produced worse results, an MSE of 252.47 in the best case, than using just 3 of the angles available, which produced an MSE of 201.34 at its best. There is the possibility of additional angles, or other combination of angles, that would produce a better prediction of locations.

  It would also be interesting to observe how location in the warehouse affects the overall signal from specific routers. From the histograms in Figure 3, there seems to be correlation between the number of walls between a router and the signal strength. If we observe the frequency of signals originating from the router ending in 90, there seems to be a dip between signals -60 and -65. This could be subject to some additional walls that interfere with the signal and don't allow an accurate representation of what the signal strength should be at a given location. The adverse of this can be demonstrated by the router ending in 81. This router has a normal distribution of signals which could indicate that the signals reach each point with the signal that it should be reached without the interference of additional walls.

  The weighting function that was used to weight the signals could change to improve the results. The current method used assumes that the signal strength is directly related to the distance and is used in place of the distance to get a weight for the signal. It is possible that there is a better relationship between signal strength and distance that would better relate the two and give more accurate predictions of location. Each of these changes, either separate or in conjunction with one another, could be used in future analysis to obtain more accurate and better results. 