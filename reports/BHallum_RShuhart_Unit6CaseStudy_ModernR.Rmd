---
title: "Predicting Location via Indoor Positioning Systems"
subtitle: MSDS 7333-401
author: "Brett Hallum, Chris Ficklin, and Ryan Shuhart"
date: February 2016
output: html_notebook
#output: pdf_document <- to be used for submission
---
## Abstract
blah blah blah...

## Introduction
blah blah blah...

## Description of Data
blah blah

## Brief Exploration of the Data
I like to paint by color..


```{r, include=FALSE}
# Libraries
library(dplyr)
library(tidyr)
library(ggplot2)
library(DataExplorer)
library(class) #KNN Classifier
library(FNN) #KNN Regression
```



### Import Pre-processed Data
```{r}
# Processed Data
offline <- readRDS("../data/processed/offline.rds")
online_allmacs <- readRDS("../data/processed/online_allmacs.rds")

# All accesspoints
allsigs <- c(
  "sig_cd", # Access Point #?
  "sig_c0", # Access Point #?
  "sig_c6", # Access Point #?
  "sig_81", # Access Point #?
  "sig_8a", # Access Point #?
  "sig_8d", # Access Point #?
  "sig_90"  # Access Point #?
             )
```
### Data Description
Offline data is this ... and is use as training...

Online data is the test data...

#### Create Data Set by Time
```{r}
offlineByTime <- group_by(offline, time, posXY, mac,  angle) %>%
  summarize(avgSig = mean(signal)) %>%
  spread(mac, avgSig) %>%
  ungroup()%>%
  rename(sig_cd = `00:0f:a3:39:dd:cd`,
         sig_c0 = `00:0f:a3:39:e1:c0`, 
         sig_c6 = `00:14:bf:3b:c7:c6`,
         sig_81 = `00:14:bf:b1:97:81`,
         sig_8a = `00:14:bf:b1:97:8a`,
         sig_8d = `00:14:bf:b1:97:8d`,
         sig_90 = `00:14:bf:b1:97:90`)

head(offlineByTime)
```
```{r}
dim(offlineByTime)
```
The offlineByTime data frame is generated by pivoting the mac addresses and signal strength from rows to columns. This pivot makes the shape of the data wider, but reduces the rows from 914,951 to 146,074. The columns 'orientation', 'rawTime', 'posX', and 'posY' are excluded for this view of the data. 

### Exploratoration of Offline Data

```{r, echo=FALSE}
AP <- data.frame(Label=c("sig_c0", "sig_8a", "sig_c6", "sig_90", "sig_8d", "sig_81"),
                 posX=c(7.5,2.5,12.8,1,33.5,33.5), 
                 posY=c(6.3,-.8,-2.8,14.0,9.3,2.8), 
                 Type="Access Point")

offlinePoints <- unique(offline[,c("posX","posY")])
offlinePoints$Type <- "Offine - Training"

onlinePoints <- unique(online_allmacs[,c("posX","posY")])
onlinePoints$Type <- "Online - Test"

building <- rbind(offlinePoints, select(AP, -Label), onlinePoints)

ggplot(building, aes(x=posX, y=posY)) + 
  geom_point(aes(shape=Type, color=Type)) + 
  geom_text(data=filter(AP, !(Label %in% c("sig_90", "sig_8d"))), aes(label=Label), nudge_y = -.6) +
  geom_text(data=filter(AP, Label == "sig_90"), aes(label=Label), nudge_x = 2) +
  geom_text(data=filter(AP, Label == "sig_8d"), aes(label=Label), nudge_x = -2) +
  labs(title="Floor Plan") + 
  scale_shape_manual(values = c(8,16,1)) +
  scale_colour_manual(values=c("red","black","blue")) +
  theme_bw() +
  theme(axis.title.x=element_blank(), 
        axis.title.y=element_blank(), 
        axis.text.x=element_blank(), 
        axis.text.y=element_blank(),
        panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),
        axis.ticks=element_blank())
```

#### Missing Data
```{r}
offlineByTime[,allsigs] %>% summarize_each(funs(sum(is.na(.))))
```
```{r}
PlotMissing(offlineByTime)
```

[...Insert commentary about the missing data...]

```{r}
paste("There are ", format(sum(complete.cases(offlineByTime)),big.mark=",",scientific=FALSE),
      " (", sprintf("%.1f", sum(complete.cases(offlineByTime))/nrow(offlineByTime)*100), "%)", 
      " complete rows of data.", sep="")
```



#### Histogram of Signal Strengths
```{r}
HistogramContinuous(offlineByTime[,allsigs])
```

#### Correlation of Signal Stregths <- Might be something to dicuss here or maybe not
```{r}
CorrelationContinuous(offlineByTime[,allsigs], use = "na.or.complete")
```

#### Create Train Data Set by Using Average Signal
```{r}
offlineByAvgSig <- group_by(offline, posXY, posX, posY, mac,  angle) %>%
  summarize(avgSig = mean(signal)) %>%
  spread(mac, avgSig) %>%
  ungroup()%>%
  rename(sig_cd = `00:0f:a3:39:dd:cd`,
         sig_c0 = `00:0f:a3:39:e1:c0`, 
         sig_c6 = `00:14:bf:3b:c7:c6`,
         sig_81 = `00:14:bf:b1:97:81`,
         sig_8a = `00:14:bf:b1:97:8a`,
         sig_8d = `00:14:bf:b1:97:8d`,
         sig_90 = `00:14:bf:b1:97:90`)

head(offlineByAvgSig)

```
#### Check if Missing Data After Average Aggregation
```{r}
offlineByAvgSig[,allsigs] %>% summarize_each(funs(sum(is.na(.))))
```

### Online Data
Online Data has duplicate observations given the time, position, mac, and angle
```{r}
percDuplicated <- nrow(online_allmacs[duplicated(online_allmacs[,c("time", "posXY", "mac", "angle")]),])/nrow(online_allmacs)

paste(sprintf("%.1f", percDuplicated*100), "% of the online observations are duplicated.", sep="")
```

Online data used for knn will average the signal observations 
```{r}
onlineByAvgSig <- group_by(online_allmacs, posXY, posX, posY, mac,  angle) %>%
  summarize(avgSig = mean(signal)) %>%
  spread(mac, avgSig)%>%
  ungroup()%>%
  rename(sig_cd = `00:0f:a3:39:dd:cd`,
         sig_c0 = `00:0f:a3:39:e1:c0`, 
         sig_c6 = `00:14:bf:3b:c7:c6`,
         sig_81 = `00:14:bf:b1:97:81`,
         sig_8a = `00:14:bf:b1:97:8a`,
         sig_8d = `00:14:bf:b1:97:8d`,
         sig_90 = `00:14:bf:b1:97:90`) 


head(onlineByAvgSig)
```


### Using KNN Regression for K = 1, 3, & 5 using all angles
```{r}
offlinePosX <- offlineByAvgSig$posX
offlinePosY <- offlineByAvgSig$posY
offline_signals <- select(offlineByAvgSig, -posXY, -posX, -posY, -angle)
online_signals <- select(onlineByAvgSig, -posXY, -posX, -posY, -angle)

#k = 1
test_estXk1 <- knn.reg(offline_signals, online_signals, offlinePosX, k=1)$pred
test_estYk1 <- knn.reg(offline_signals, online_signals, offlinePosY, k=1)$pred
test_estXYk1 <- data.frame(posX = test_estXk1, posY = test_estYk1)

#k = 3
test_estXk3 <- knn.reg(offline_signals, online_signals, offlinePosX, k=3)$pred
test_estYk3 <- knn.reg(offline_signals, online_signals, offlinePosY, k=3)$pred
test_estXYk3 <- data.frame(posX = test_estXk3, posY = test_estYk3)

#k = 5
test_estXk5 <- knn.reg(offline_signals, online_signals, offlinePosX, k=5)$pred
test_estYk5 <- knn.reg(offline_signals, online_signals, offlinePosY, k=5)$pred
test_estXYk5 <- data.frame(posX = test_estXk5, posY = test_estYk5)

#MSE
#sum( rowSums( (estXY - actualXY)^2) )
sum( rowSums( (test_estXYk1 - onlineByAvgSig[,c("posX", "posY")])^2) )
sum( rowSums( (test_estXYk3 - onlineByAvgSig[,c("posX", "posY")])^2) )
sum( rowSums( (test_estXYk5 - onlineByAvgSig[,c("posX", "posY")])^2) )
```


```{r}
# function to estimate using KNN the X Y of the online data
predictXYKNN <- function(offline_signals, online_signals, 
                         offline_posX, offline_posY, k){
  
  estX <- knn.reg(offline_signals, online_signals, offline_posX$posX, k=k)$pred
  estY <- knn.reg(offline_signals, online_signals, offline_posY$posY, k=k)$pred
  
  estXYk <- data.frame(posXest = estX, posYest = estY)
  
  return(estXYk)
}


# function to evaluate a series of k values and only looking at angle directly
# to the left or the right
k_Eval <- function(offlineByAvgSig, onlineByAvgSig, k_max){
  ks=numeric()
  MSE=numeric()
  
  for (k in 1:k_max){
    ks[k] <- k
    resdf <- data.frame(posXest=numeric(), posYest=numeric(), posX=numeric(),  posY=numeric())
    
    possibleAngles <- c(0,  45,  90, 135, 180, 225, 270, 315)
    
    # Goes through all possible online angles and runs KNN only on a filtered
    # offline group containing only the neighboring angles. Each group is a set
    # of online observations sharing the same angle. This group then uses KNN
    # on the offline group with the same angle and the angles directly to the 
    # left and right. After all the possible online angles are predicted, the
    # results are scored.
    for (ang in possibleAngles){ 
      angleLeft <- (ang - 45 + 360)%%360
      angleRight <-(ang + 45 + 360)%%360
  
      offline_signals <- select(
        filter(offlineByAvgSig, angle %in% c(angleLeft, ang, angleRight)), 
        -posXY, -posX, -posY, -angle)
      
      offline_posX <- select(
        filter(offlineByAvgSig, angle %in% c(angleLeft, ang, angleRight)), 
        posX)
      
      offline_posY <- select(
        filter(offlineByAvgSig, angle %in% c(angleLeft, ang, angleRight)), 
        posY)
    
      online_signals <- select(
        filter(onlineByAvgSig, angle == ang),
        -posXY, -posX, -posY, -angle)
      
      online_positions_val <- select(
        filter(onlineByAvgSig, angle == ang),
        posX, posY)
      
      estXY <- predictXYKNN(offline_signals, online_signals, 
                             offline_posX, offline_posY, k)
    
      # The results of each group have to be combined before scoring
      resdf <- rbind(resdf, cbind(estXY, online_positions_val))
    }
    
    #MSE of all the completed online predictions
    MSE[k] <- sum( rowSums( (resdf[,c("posXest","posYest")] - resdf[,c("posX","posY")])^2) )
  }
  return(data.frame(k=ks, MSE=MSE))
}
```


### Plot MSE for k 1-20 using All AP signals
```{r}
k_20 <- k_Eval(offlineByAvgSig, onlineByAvgSig, 20)
print(paste("The best MSE:",top_n(k_20,-1,MSE)[2], "with a k of:", top_n(k_20,-1,MSE)[1])) # Negative 1 is to get lowest MSE
```

```{r}
# Plot of MSE for K with all AP signals
ggplot(k_20, aes(k, MSE)) + 
  geom_line() + 
  theme_classic() + 
  labs(title="Using all 7 AP Signals") +
  geom_text(data=top_n(k_20,-1,MSE), aes(label=MSE), nudge_y = 20)

```


### Without e1:c0
```{r}
k_20_no_e1c0 <- k_Eval(select(offlineByAvgSig, -sig_c0), 
                       select(onlineByAvgSig, -sig_c0), 20)
print(paste("The best MSE:",top_n(k_20_no_e1c0,-1,MSE)[2], "with a k of:", top_n(k_20_no_e1c0,-1,MSE)[1])) # Negative 1 is to get lowest MSE
```
```{r}
# Plot of MSE for K without e1:c0
ggplot(k_20_no_e1c0, aes(k, MSE)) + 
  geom_line() + 
  theme_classic() + 
  labs(title="Using 00:0f:a3:39:dd:cd AP Signal") +
  geom_text(data=top_n(k_20_no_e1c0,-1,MSE), aes(label=MSE), nudge_y = 20)

```

### Without dd:cd
```{r}
k_20_no_ddcd <- k_Eval(select(offlineByAvgSig, -sig_cd), 
                       select(onlineByAvgSig, -sig_cd), 20)
print(paste("The best MSE:",top_n(k_20_no_ddcd,-1,MSE)[2], "with a k of:", top_n(k_20_no_e1c0,-1,MSE)[1])) # Negative 1 is to get lowest MSE
```
```{r}
# Plot of MSE for K without dd:cd
ggplot(k_20_no_ddcd, aes(k, MSE)) + 
  geom_line() + 
  theme_classic() + 
  labs(title="Using 00:0f:a3:39:e1:c0 AP Signal") +
  geom_text(data=top_n(k_20_no_ddcd,-1,MSE), aes(label=MSE), nudge_y = 20)

```





training set by time - done


Training set averaged signal - done


Training set weighted average signal

keep only 00:0f:a3:39:e1:c0 - done for no weighting

keep only 00:0f:a3:39:dd:cd - done for no weighting

inlcude both - done for no weighting

*Adding angle seems to make it worse. currently not just looking at the closest angles.

## Which of these two MAC addresses should be used and which should not be used for RTLS? 
It appears keeping both has the lowest MSE 


## Which MAC address yields the best prediction of location?
00:0f:a3:39:dd:cd


## Does using data for both MAC addresses simultaneously yield more, or less, accurate prediction of location?
more accurate


For what range of values of weights are you able to obtain better prediction values than for the unweighted k-nearest neighbor approach? 

## Weighted

In attempt to impove the predicted location, stronger signals will be upweighted relative to the other.
## $\frac{1/d}{\sum_{i=1}^k 1/d_i}$ 
```{r}
# W

wt_signals <- function(ByAvgSig){
  signals <- select(ByAvgSig, -posXY, -posX, -posY, -angle) 
  loc_ang <- select(ByAvgSig, posXY, posX, posY, angle)
  
  weighted_signals <- (1/signals) / rowSums(1/signals)
  
  return(cbind(loc_ang, weighted_signals))
}

wtOfflineByAvgSig <- wt_signals(offlineByAvgSig)
wtOnlineByAvgSig <- wt_signals(onlineByAvgSig)


```
