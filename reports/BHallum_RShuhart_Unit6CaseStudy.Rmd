---
title: "Predicting Location via Indoor Positioning Systems"
subtitle: MSDS 7333-401
author: "Brett Hallum, Chris Ficklin, and Ryan Shuhart"
date: February 2016
output: html_notebook
#output: pdf_document <- to be used for submission
---
# Abstract
blah blah blah...

# Introduction
blah blah blah...

# Description of Data
blah blah

# Brief Exploration of the Data
I like to paint by color...



```{r, include=FALSE}
# Libraries
library(dplyr)
library(ggplot2)
```

```{r}
# Data
train <- readRDS("../data/processed/offline.rds")
trainSum <- readRDS("../data/processed/offlinesummary.rds")
test <- readRDS("../data/processed/online.rds")
testSum <- readRDS("../data/processed/onlinesummary.rds")
```

```{r}
unique(test$mac)
unique(train$mac)
unique(testSum$mac)
unique(trainSum$mac)
```


```{r}
#Reshapes data into form simlar to testSum
reshapeSS = function(data, varSignal = "signal", 
                     keepVars = c("posXY", "posX","posY"),
                     sampleAngle = FALSE, 
                     refs = seq(0, 315, by = 45)) {
  byLocation =
    with(data, by(data, list(posXY), 
                  function(x) {
                    if (sampleAngle) {
                      x = x[x$angle == sample(refs, size = 1), ]}
                    ans = x[1, keepVars]
                    avgSS = tapply(x[ , varSignal ], x$mac, mean)
                    y = matrix(avgSS, nrow = 1, ncol = 6,
                               dimnames = list(ans$posXY,
                                               names(avgSS)))
                    cbind(ans, y)
                  }))

  newDataSS = do.call("rbind", byLocation)
  return(newDataSS)
}


#Selects angle and reshapes data frame for a given signal
selectTrain = function(angleNewObs, signals = NULL, m = 1){
  # m is the number of angles to keep between 1 and 5
  refs = seq(0, by = 45, length  = 8)
  nearestAngle = roundOrientation(angleNewObs)
  
  if (m %% 2 == 1) 
    angles = seq(-45 * (m - 1) /2, 45 * (m - 1) /2, length = m)
  else {
    m = m + 1
    angles = seq(-45 * (m - 1) /2, 45 * (m - 1) /2, length = m)
    if (sign(angleNewObs - nearestAngle) > -1) 
      angles = angles[ -1 ]
    else 
      angles = angles[ -m ]
  }
  angles = angles + nearestAngle
  angles[angles < 0] = angles[ angles < 0 ] + 360
  angles[angles > 360] = angles[ angles > 360 ] - 360
  angles = sort(angles) 
  
  offlineSubset = signals[ signals$angle %in% angles, ]
  reshapeSS(offlineSubset, varSignal = "avgSignal")
}

#Finds the nearest neighbor
findNN = function(newSignal, trainSubset) {
  diffs = apply(trainSubset[ , 4:9], 1, 
                function(x) x - newSignal)
  dists = apply(diffs, 2, function(x) sqrt(sum(x^2)) )
  closest = order(dists)
  return(trainSubset[closest, 1:3 ])
}

#Finds the weighted nearest neighbor
findWeightedNN = function(newSignal, trainSubset) {
  diffs = apply(trainSubset[ , 4:9], 1, 
                function(x) x - newSignal)
  dists = apply(diffs, 2, function(x) sqrt(sum(x^2)) )
  
  inverse_diffs_sum = 0
  
  for (dist in dists){
    inverse_diffs_sum = inverse_diffs_sum + 1/dist
  }
  
  for(dist in dists){
    dist = (1/dist)/inverse_diffs_sum * dist
  }
  
  dists
  
  closest = order(dists)
  return(trainSubset[closest, 1:3 ])
}

#predicts the x and y location of the emitter
predXY = function(newSignals, newAngles, trainData, 
                  numAngles = 1, k = 3){
  
  closeXY = list(length = nrow(newSignals))
  
  for (i in 1:nrow(newSignals)) {
    trainSS = selectTrain(newAngles[i], trainData, m = numAngles)
    closeXY[[i]] = 
      findNN(newSignal = as.numeric(newSignals[i, ]), trainSS)
  }

  estXY = lapply(closeXY, 
                 function(x) sapply(x[ , 2:3], 
                                    function(x) mean(x[1:k])))
  estXY = do.call("rbind", estXY)
  return(estXY)
}

#predicts the x and y location of the emitter for weighted Nearest Neighbor
predWeightedXY = function(newSignals, newAngles, trainData, 
                  numAngles = 1, k = 3){
  
  closeXY = list(length = nrow(newSignals))
  
  for (i in 1:nrow(newSignals)) {
    trainSS = selectTrain(newAngles[i], trainData, m = numAngles)
    closeXY[[i]] = 
      findWeightedNN(newSignal = as.numeric(newSignals[i, ]), trainSS)
  }

  estXY = lapply(closeXY, 
                 function(x) sapply(x[ , 2:3], 
                                    function(x) mean(x[1:k])))
  estXY = do.call("rbind", estXY)
  return(estXY)
}
```

```{r}
#X and Y estimates for 3 NN
estXYk3 = predXY(newSignals = testSum[ , 6:11], 
                 newAngles = testSum[ , 4], 
                 trainSum, numAngles = 3, k = 3)

#X and Y estimates for 1 NN
estXYk1 = predXY(newSignals = testSum[ , 6:11], 
                 newAngles = testSum[ , 4], 
                 trainSum, numAngles = 3, k = 1)

```

```{r}
#Calculate error in estimates
calcError = 
function(estXY, actualXY) 
   sum( rowSums( (estXY - actualXY)^2) )

actualXY = testSum[ , c("posX", "posY")]
sapply(list(estXYk1, estXYk3), calcError, actualXY)
```

```{r}
keepVars = c("posXY", "posX","posY", "orientation", "angle")

train = train[ train$mac != "00:0f:a3:39:dd:cd", ]

testCVSummary = reshapeSS(train, keepVars=keepVars, sampleAngle=TRUE)

#Selection of appropriate K for NN
v = 11
permuteLocs = sample(unique(trainSum$posXY))
permuteLocs = matrix(permuteLocs, ncol = v, 
                     nrow = floor(length(permuteLocs)/v))

K = 20
err = rep(0, K)

for (j in 1:v) {
  testFold = subset(testCVSummary, 
                      posXY %in% permuteLocs[ , j])
  trainFold = subset(trainSum,
                       posXY %in% permuteLocs[ , -j])
  actualFold = onlineFold[ , c("posX", "posY")]
  
  for (k in 1:K) {
    estFold = predXY(newSignals = testFold[ , 6:11],
                     newAngles = testFold[ , 4], 
                     trainFold, numAngles = 3, k = k)
    err[k] = err[k] + calcError(estFold, actualFold)
  }
}

```

```{r}
#Final KNN with best K selected of 5
estXYk5 = predXY(newSignals = testSum[ , 6:11], 
                 newAngles = testSum[ , 4], 
                 trainSum, numAngles = 3, k = 5)

calcError(estXYk5, actualXY)
```
```{r}
estXYk5 = predWeightedXY(newSignals = testSum[ , 6:11], 
                 newAngles = testSum[ , 4], 
                 trainSum, numAngles = 3, k = 5)

calcError(estXYk5, actualXY)
```
```{r}
trainSS = selectTrain(45, trainSum, m = 3)

weightedNN = findWeightedNN(testSum[ , 6:11], trainSS)

weightedNN
```



